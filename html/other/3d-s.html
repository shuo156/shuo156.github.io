<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>极限性能检测3DS-没60是飞舞</title>
<style>
  body,html {margin:0; padding:0; overflow:hidden; background:#111;}
  #fps {
    position: fixed;
    top: 5px; right: 5px;
    color: #0f0;
    font-family: monospace;
    font-size: 16px;
    z-index: 9999;
    user-select:none;
  }
  canvas { display:block; }
</style>
</head>
<body>
<div id="fps">FPS: 0</div>
<script src="https://shuo156.github.io/js/three.js"></script>
<script>
(() => {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:"high-performance"});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);
  
  camera.position.set(0, 10, 40);

  // 环境光
  scene.add(new THREE.AmbientLight(0x404040, 1.5));

  // 多阴影光源
  const lights = [];
  for(let i=0; i<5; i++){
    const l = new THREE.PointLight(0xffffff, 1, 100);
    l.position.set(Math.cos(i*1.2)*20, 15, Math.sin(i*1.2)*20);
    l.castShadow = true;
    l.shadow.mapSize.width = 2048;
    l.shadow.mapSize.height = 2048;
    l.shadow.camera.near = 0.5;
    l.shadow.camera.far = 100;
    scene.add(l);
    lights.push(l);
  }

  // 地面
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(200,200),
    new THREE.ShadowMaterial({opacity:0.6})
  );
  floor.rotation.x = -Math.PI/2;
  floor.position.y = -5;
  floor.receiveShadow = true;
  scene.add(floor);

  // 超高细节几何体 基础几何体（用Icosahedron 3细分避免顶点太多）
  const baseGeom = new THREE.IcosahedronGeometry(1, 3);
  
  // 50个阉割版
  const meshes = [];
  const meshCount = 50;

  for(let i=0; i<meshCount; i++){
    const mat = new THREE.MeshStandardMaterial({
      color: new THREE.Color(`hsl(${(i*10)%360}, 80%, 50%)`),
      roughness: 0.3,
      metalness: 0.7,
    });
    const mesh = new THREE.Mesh(baseGeom.clone(), mat);
    mesh.position.set(
      (Math.random()-0.5)*50,
      (Math.random()*10),
      (Math.random()-0.5)*50
    );
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    meshes.push(mesh);
  }

  // CPU侧顶点动态修改，制造CPU瓶颈
  // 预先缓存顶点原始位置
  const originalPositions = [];
  meshes.forEach(mesh => {
    const posAttr = mesh.geometry.attributes.position;
    originalPositions.push(new Float32Array(posAttr.array));
  });

  // 粒子系统降低数量以节约资源
  const particleCount = 5000;
  const particlesGeom = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const velocities = new Float32Array(particleCount * 3);
  for(let i=0; i<particleCount; i++){
    positions[i*3] = (Math.random()-0.5)*60;
    positions[i*3+1] = (Math.random()-0.5)*20 + 5;
    positions[i*3+2] = (Math.random()-0.5)*60;
    velocities[i*3] = (Math.random()-0.5)*0.02;
    velocities[i*3+1] = (Math.random()-0.5)*0.02;
    velocities[i*3+2] = (Math.random()-0.5)*0.02;
  }
  particlesGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const particlesMat = new THREE.PointsMaterial({
    color: 0x66aaff,
    size: 0.05,
    transparent: true,
    opacity: 0.6,
    sizeAttenuation: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
  });
  const particles = new THREE.Points(particlesGeom, particlesMat);
  scene.add(particles);

  // FPS显示
  let fpsEl = document.getElementById('fps'), lastTime = performance.now(), frames = 0;

  // 旋转变量
  let rotY = 0;

  function animate() {
    requestAnimationFrame(animate);

    rotY += 0.005;

    // 动态移动灯光轨迹
    lights.forEach((l,i) => {
      l.position.x = 20 * Math.cos(rotY + i*1.5);
      l.position.z = 20 * Math.sin(rotY + i*1.5);
    });

    // CPU顶点波动，每个模型顶点都动，制造CPU压力
    meshes.forEach((mesh, idx) => {
      const posAttr = mesh.geometry.attributes.position;
      const orig = originalPositions[idx];
      const array = posAttr.array;
      for(let i=0; i<array.length; i+=3){
        // 基于时间和顶点索引波动顶点Y
        array[i+1] = orig[i+1] + Math.sin(performance.now()*0.002 + i + idx)*0.15;
      }
      posAttr.needsUpdate = true;

      mesh.rotation.y = rotY * (1 + idx*0.001);
    });

    // 粒子位置更新
    const pos = particles.geometry.attributes.position.array;
    for(let i=0; i<particleCount; i++){
      let idx = i*3;
      pos[idx] += velocities[idx];
      if(pos[idx] > 30 || pos[idx] < -30) velocities[idx] *= -1;

      pos[idx+1] += velocities[idx+1];
      if(pos[idx+1] > 15 || pos[idx+1] < 0) velocities[idx+1] *= -1;

      pos[idx+2] += velocities[idx+2];
      if(pos[idx+2] > 30 || pos[idx+2] < -30) velocities[idx+2] *= -1;
    }
    particles.geometry.attributes.position.needsUpdate = true;

    renderer.render(scene, camera);

    frames++;
    let now = performance.now();
    if(now - lastTime >= 1000){
      fpsEl.textContent = 'FPS: ' + frames;
      frames = 0;
      lastTime = now;
    }
  }

  animate();

  // 窗口自适应
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>
</body>
</html>