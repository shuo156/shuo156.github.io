<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>复杂光影粒子性能检测</title>
<style>
  body,html{margin:0;padding:0;overflow:hidden;background:#111;}
  #fps{
    position: fixed;
    top: 5px;
    right: 5px;
    color: #0f0;
    font-family: monospace;
    font-size: 16px;
    z-index: 9999;
    user-select:none;
  }
  canvas{display:block;}
</style>
</head>
<body>
<div id="fps">FPS: 0</div>
<script src="https://shuo156.github.io/js/three.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

camera.position.set(0,2,5);

const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
scene.add(ambientLight);

const pointLight = new THREE.PointLight(0xffffff, 1);
pointLight.position.set(5,5,5);
pointLight.castShadow = true;
pointLight.shadow.mapSize.width = 512;
pointLight.shadow.mapSize.height = 512;
pointLight.shadow.camera.near = 0.5;
pointLight.shadow.camera.far = 20;
scene.add(pointLight);

const floorGeo = new THREE.PlaneGeometry(20, 20);
const floorMat = new THREE.ShadowMaterial({opacity:0.4});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -1;
floor.receiveShadow = true;
scene.add(floor);

const geom = new THREE.IcosahedronGeometry(1,2);
for(let i=0; i<geom.attributes.position.count; i++){
  let v = new THREE.Vector3().fromBufferAttribute(geom.attributes.position, i);
  v.multiplyScalar(1 + 0.1*Math.sin(i*5));
  geom.attributes.position.setXYZ(i, v.x, v.y, v.z);
}
geom.computeVertexNormals();

const mat = new THREE.MeshStandardMaterial({
  color: 0x2194ce,
  roughness: 0.3,
  metalness: 0.7,
  flatShading: false
});

const mesh = new THREE.Mesh(geom, mat);
mesh.castShadow = true;
mesh.receiveShadow = true;
scene.add(mesh);

const particleCount = 500;
const particlesGeom = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
for(let i=0; i<particleCount; i++){
  positions[i*3] = (Math.random() - 0.5) * 6;
  positions[i*3+1] = (Math.random() - 0.5) * 4 + 1;
  positions[i*3+2] = (Math.random() - 0.5) * 6;
}
particlesGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));

const particlesMat = new THREE.PointsMaterial({
  color: 0x44aaff,
  size: 0.05,
  transparent: true,
  opacity: 0.8,
  sizeAttenuation: true
});

const particles = new THREE.Points(particlesGeom, particlesMat);
scene.add(particles);

let fpsEl = document.getElementById('fps'), lastTime = performance.now(), frames = 0;

let isDragging = false, lastX = 0, lastY = 0;
let rotX = 0, rotY = 0;
let targetRotX = 0, targetRotY = 0;
let scale = 1;
const minScale = 0.5, maxScale = 2.5;

function clamp(value,min,max){return value<min?min:value>max?max:value;}

function onPointerDown(e){
  isDragging = true;
  lastX = e.clientX || e.touches[0].clientX;
  lastY = e.clientY || e.touches[0].clientY;
}
function onPointerMove(e){
  if(!isDragging)return;
  let x = e.clientX || e.touches[0].clientX;
  let y = e.clientY || e.touches[0].clientY;
  let dx = (x - lastX) / window.innerWidth * Math.PI * 2;
  let dy = (y - lastY) / window.innerHeight * Math.PI * 2;
  targetRotY += dx;
  targetRotX += dy;
  targetRotX = clamp(targetRotX, -Math.PI/2, Math.PI/2);
  lastX = x;
  lastY = y;
}
function onPointerUp(e){isDragging = false;}

function onWheel(e){
  e.preventDefault();
  scale -= e.deltaY * 0.0015;
  scale = clamp(scale, minScale, maxScale);
}

renderer.domElement.addEventListener('mousedown', onPointerDown);
renderer.domElement.addEventListener('touchstart', onPointerDown);
renderer.domElement.addEventListener('mousemove', onPointerMove);
renderer.domElement.addEventListener('touchmove', onPointerMove, {passive:false});
renderer.domElement.addEventListener('mouseup', onPointerUp);
renderer.domElement.addEventListener('touchend', onPointerUp);
renderer.domElement.addEventListener('wheel', onWheel, {passive:false});

function animate(){
  requestAnimationFrame(animate);
  rotX += (targetRotX - rotX) * 0.1;
  rotY += (targetRotY - rotY) * 0.1;
  mesh.rotation.x = rotX;
  mesh.rotation.y = rotY;
  mesh.scale.set(scale, scale, scale);

  particles.rotation.y += 0.002;
  particles.rotation.x += 0.001;

  renderer.render(scene, camera);

  frames++;
  let now = performance.now();
  if(now - lastTime >= 1000){
    fpsEl.textContent = 'FPS: ' + frames;
    frames = 0;
    lastTime = now;
  }
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>