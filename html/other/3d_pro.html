<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>手机极限性能压测 - 三档模式</title>
<style>
body,html{margin:0;padding:0;overflow:hidden;background:#000;}
#fps{
  position:fixed;top:5px;left:5px;color:#0f0;
  font-family:monospace;font-size:16px;z-index:999;
}
canvas{display:block;}
</style>
</head>
<body>
<div id="fps">FPS: 0</div>

<!-- Three.js r148 + 后期处理库 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/examples/js/postprocessing/ShaderPass.js"></script>

<script>
// ==== 可调节参数 ==== //
let mode = 2; // 1=轻量 2=中量 3=极限
const settings = {
  1: { modelCount: 500, deformStrength: 0.2, lights: 2, shaderLoops: 10 },
  2: { modelCount: 1200, deformStrength: 0.5, lights: 4, shaderLoops: 25 },
  3: { modelCount: 3000, deformStrength: 1.0, lights: 6, shaderLoops: 50 }
};
const cfg = settings[mode];

// ==== Three.js 基础 ==== //
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 0, 50);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// 环境光
scene.add(new THREE.AmbientLight(0xffffff, 0.3));
// 多点光源
for(let i=0; i<cfg.lights; i++){
  const pl = new THREE.PointLight(0xffffff, 1, 500);
  pl.position.set(
    Math.random()*200-100,
    Math.random()*200-100,
    Math.random()*200-100
  );
  scene.add(pl);
}

// ==== 高面模型生成 ==== //
const meshes = [];
const baseGeo = new THREE.IcosahedronGeometry(1, 3); // 高细分
const mat = new THREE.MeshStandardMaterial({color:0x3399ff, metalness:0.7, roughness:0.2});
for(let i=0; i<cfg.modelCount; i++){
  const mesh = new THREE.Mesh(baseGeo.clone(), mat.clone());
  mesh.position.set(
    Math.random()*200-100,
    Math.random()*200-100,
    Math.random()*200-100
  );
  mesh.scale.setScalar(Math.random()*1.5+0.5);
  scene.add(mesh);
  meshes.push(mesh);
}

// ==== 后期处理 Shader ==== //
const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
const crazyShader = {
  uniforms: { tDiffuse: { value: null }, time: { value: 0.0 } },
  vertexShader: `
    varying vec2 vUv;
    void main(){
      vUv = uv;
      gl_Position = projectionMatrix*modelViewMatrix*position;
    }
  `,
  fragmentShader: `
    varying vec2 vUv;
    uniform sampler2D tDiffuse;
    uniform float time;
    void main(){
      vec2 uv = vUv;
      vec4 col = texture2D(tDiffuse, uv);
      // 高负载循环
      for(int i=0;i<${cfg.shaderLoops};i++){
        col.rgb += sin(uv.x*float(i)*0.1 + time)*0.01;
        col.rgb = col.bgr;
      }
      gl_FragColor = col;
    }
  `
};
const shaderPass = new THREE.ShaderPass(crazyShader);
composer.addPass(shaderPass);

// ==== FPS 计算 ==== //
let fpsEl = document.getElementById('fps');
let lastTime = performance.now(), frames = 0;

// ==== 动画循环 ==== //
function animate(){
  requestAnimationFrame(animate);
  const t = performance.now()*0.001;

  // CPU 顶点形变
  meshes.forEach(m=>{
    const pos = m.geometry.attributes.position;
    for(let i=0;i<pos.count;i++){
      pos.setZ(i, Math.sin(i*0.1 + t)*cfg.deformStrength);
    }
    pos.needsUpdate = true;
    m.rotation.x += 0.01;
    m.rotation.y += 0.01;
  });

  shaderPass.uniforms.time.value = t;
  composer.render();

  frames++;
  const now = performance.now();
  if(now - lastTime >= 1000){
    fpsEl.textContent = "FPS: " + frames;
    frames = 0;
    lastTime = now;
  }
}
animate();

// ==== 自适应窗口大小 ==== //
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>